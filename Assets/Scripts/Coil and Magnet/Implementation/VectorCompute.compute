#pragma kernel OutwardsField
#pragma kernel SwirlField
#pragma kernel CoulombField
#pragma kernel DbField
#pragma kernel IntegrandField
//#pragma kernel ElectricField
#pragma kernel CalculateElectricField
// The buffer storing the positions
RWStructuredBuffer<float3> _Positions;

// The buffer storing the value of the vector field at each point
RWStructuredBuffer<float3> _Vectors;

// The buffer storing the value of the vector field at each point in the past
RWStructuredBuffer<float3> _MagneticFieldPast;
RWStructuredBuffer<float3> _IntegrandPast;
RWStructuredBuffer<float3> _Integrand;
// It's set every frame by the C# script.

// The (0,0,0) point of the field
float3 _CenterPosition;
float _TimeInterval;
float _TimePast;
float _TimeNow;
int _NumberOfPoints;
float _Distance;
// These buffers allow you to send additional arguments to whatever your field function is. 
StructuredBuffer<float> _FloatArgs;
StructuredBuffer<float3> _VectorArgs;
// It's up to you to parse these inside the function, so you can split them into two separate arrays
// if you choose. Just remember that not every model supports GetDimensions, so you need to figure
// out for yourself how to stop from going out of bounds. 

// You can try to make those RWStructuredBuffers, but that crashed my computer so I'm not going to
// do that. 




#include "FieldLibrary.hlsl"


#define KERNEL_NAME(fieldName) \
    [numthreads(64, 1, 1)] \
    void fieldName##Field(uint3 id : SV_DispatchThreadID) { \
        uint bufferSize; \
        uint stride; \
        _Positions.GetDimensions(bufferSize, stride); \
        if (id.x < bufferSize) { \
            _Vectors[id.x] = fieldName(_Positions[id.x] - _CenterPosition, id.x); \
        } \
    }

[numthreads(64, 1, 1)] 
void DbField(uint3 id : SV_DispatchThreadID) { 
    uint bufferSize; 
    uint stride;
    
    _Positions.GetDimensions(bufferSize, stride); 
    if (id.x < bufferSize){
        _Vectors[id.x] = 0.9 * _Vectors[id.x] + 0.1 * Db(_Positions[id.x] - _CenterPosition, id.x); 
        } 
}

#define PI 3.14159265358979323846

[numthreads(64, 1, 1)] 
void CalculateElectricField(uint3 id : SV_DispatchThreadID) {
    uint bufferSize; 
    uint stride;
    
    _Positions.GetDimensions(bufferSize, stride); 
    if (id.x < bufferSize){

        float3 v = float3(-2.0, -2.0, -2.0);
        _Vectors[id.x] = cross(v, Coulomb(_Positions[id.x] - _CenterPosition, id.x));
    }
}
//     // The Riemann sum
//     int j;
//     float3 resultNow = float3(0.0, 0.0, 0.0);
//     for (j = 0; j < _NumberOfPoints; j++){
//         resultNow += Integrand(_Positions[id.x] - _CenterPosition, j) * 0.001 * 1000; // 0.001 is the "volume" and 1000 is the extra scaling factor
//     }
    
//     resultNow = resultNow * (-1 / (4 * PI));
//     //_Vectors[id.x] = resultNow;
    
//     //WORRY ABOUT THIS LATER
//     float3 weightedResult = (0.1 * resultNow) + (0.90 * _IntegrandPast[id.x]);

//     if (weightedResult.x < 0.1 && weightedResult.y < 0.1 && weightedResult.z < 0.1){
//         weightedResult = float3(0.0, 0.0, 0.0);
//     }
//     _IntegrandPast[id.x] = weightedResult;
//     _Vectors[id.x] = weightedResult;
//     }
// }

KERNEL_NAME(Outwards)
KERNEL_NAME(Swirl)
KERNEL_NAME(Coulomb)
KERNEL_NAME(Integrand)