#pragma kernel OutwardsField
#pragma kernel SwirlField
#pragma kernel CoulombField
#pragma kernel DbField
#pragma kernel IntegrandField
//#pragma kernel ElectricField
#pragma kernel CalculateElectricField
// The buffer storing the positions
RWStructuredBuffer<float3> _Positions;

// The buffer storing the value of the vector field at each point
RWStructuredBuffer<float3> _Vectors;

// The buffer storing the value of the vector field at each point in the past
RWStructuredBuffer<float3> _DbArray;
RWStructuredBuffer<float3> _MagneticFieldPast;
RWStructuredBuffer<float3> _IntegrandPast;
RWStructuredBuffer<float3> _Integrand;
// It's set every frame by the C# script.

// The (0,0,0) point of the field
float3 _CenterPosition;
float _TimeInterval;
float _TimePast;
float _TimeNow;
int _NumberOfPoints;
float _Distance;
// These buffers allow you to send additional arguments to whatever your field function is. 
StructuredBuffer<float> _FloatArgs;
StructuredBuffer<float3> _VectorArgs;
// It's up to you to parse these inside the function, so you can split them into two separate arrays
// if you choose. Just remember that not every model supports GetDimensions, so you need to figure
// out for yourself how to stop from going out of bounds. 

// You can try to make those RWStructuredBuffers, but that crashed my computer so I'm not going to
// do that. 




#include "FieldLibrary.hlsl"


#define KERNEL_NAME(fieldName) \
    [numthreads(64, 1, 1)] \
    void fieldName##Field(uint3 id : SV_DispatchThreadID) { \
        uint bufferSize; \
        uint stride; \
        _Positions.GetDimensions(bufferSize, stride); \
        if (id.x < bufferSize) { \
            _Vectors[id.x] = fieldName(_Positions[id.x] - _CenterPosition, id.x); \
        } \
    }

[numthreads(64, 1, 1)] 
void DbField(uint3 id : SV_DispatchThreadID) { 
    uint bufferSize; 
    uint stride;
    
    _Positions.GetDimensions(bufferSize, stride); 
    if (id.x < bufferSize){
        _Vectors[id.x] = 0.9 * _Vectors[id.x] + 0.1 * Db(_Positions[id.x] - _CenterPosition, id.x); 
        } 
}

#define PI 3.14159265358979323846

[numthreads(64, 1, 1)] 
void CalculateElectricField(uint3 id : SV_DispatchThreadID) {
    uint bufferSize; 
    uint stride;
    
    _Positions.GetDimensions(bufferSize, stride); 
    if (id.x < bufferSize){
        Db(_Positions[id.x] - _CenterPosition, id.x);
        // The Riemann sum
        int j;
        float3 resultNow = float3(0.0, 0.0, 0.0);
        for (j = 0; j < _NumberOfPoints; j++){
            float3 displacement = _Positions[id.x] - _Positions[j];
            if (length(displacement) >.0000001){
                resultNow += (cross(_DbArray[j], displacement)) / pow(length(displacement),3);
            }
        }
        
        resultNow = resultNow * (-1 / (4 * PI)) * 0.01; // 0.01 is to scale down the vectors
        //_Vectors[id.x] = resultNow;
        
        //WORRY ABOUT THIS LATER
        float3 weightedResult = (0.9 * resultNow) + (0.1 * _IntegrandPast[id.x]);

        _IntegrandPast[id.x] = weightedResult;
        _Vectors[id.x] = weightedResult;
        }
}

KERNEL_NAME(Outwards)
KERNEL_NAME(Swirl)
KERNEL_NAME(Coulomb)
KERNEL_NAME(Integrand)